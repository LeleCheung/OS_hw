
2.1 fork、exec、wait等是进程操作的常用API，请调研了解这些API的使用方法。
（1）请写一个C程序，该程序首先创建一个1到10的整数数组，然后创建一个子进程，并让子进程对前述数组所有元素求和，并打印求和结果。等子进程完成求和后，父进程打印“parent process finishes”,再退出。
（2）在（1）所写的程序基础上，当子进程完成数组求和后，让其执行ls -l命令(注：该命令用于显示某个目录下文件和子目录的详细信息)，显示你运行程序所用操作系统的某个目录详情。例如，让子进程执行 ls -l /usr/bin目录，显示/usr/bin目录下的详情。父进程仍然需要等待子进程执行完后打印“parent process finishes”,再退出。
（3）请阅读XV6代码（https://pdos.csail.mit.edu/6.828/2023/xv6.html），找出XV6代码中对进程控制块（PCB）的定义代码，说明其所在的文件，以及当fork执行时，对PCB做了哪些操作？

提交内容
（1）	所写C程序，打印结果截图，说明等
（2）	所写C程序，打印结果截图，说明等
（3）	代码分析介绍

解答：
（0）API调研
	1）pid_t fork(void)  
	位于头文件unistd.h，fork 函数会新生成一个进程，调用 fork 函数的进程为父进程，新生成的进程为子进程，而且这个子进程和父进程几乎一样。在调用fork后，fork的所有代码会执行两遍，例如分支判断语句也判断两次。fork仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值：
	在父进程中，fork返回新创建子进程的进程ID；
	在子进程中，fork返回0；
	如果出现错误，fork返回一个负值；
	另外，写时分配策略使得子进程有写段行为时，才会为子进程分配新的物理空间。若不然，子进程与父进程的代码段、数据段、堆栈的物理地址完全一样。

	2）exec函数族
	用fork函数创建子进程后，子进程往往要调用位于头文件unistd.h的一种exec函数以执行另一个程序。当进程调用一种exec函数时，该进程执行的程序完全替换为新程序，而新程序则从其main函数开始执行。因为调用exec并不创建新进程，所以前后的进程ID并未改变。exec只是用一个全新的程序替换了当前进程的正文、数据、堆和栈段。

	下面是 exec 函数族的常见形式：
	int execl(const char *path, const char *arg, ...); : 用于执行指定路径的可执行文件（需要使用绝对或相对路径），并用数组方式传入参数。
	int execlp(const char *file, const char *arg, ...); : 用于执行当前目录或环境变量 PATH 变量下可执行文件，并用数组方式传入参数。
	int execle(const char *path, const char *arg, ..., char *const envp[]); : 用于执行指定路径的可执行文件，并用数组方式传入参数和环境变量。
	int execv(const char *path, char *const argv[]); : 用于执行指定路径的可执行文件（需要使用绝对或相对路径），并用字符指针数组方式传入参数。
	int execvp(const char *file, char *const argv[]); : 用于执行当前目录或环境变量 PATH 变量下可执行文件，并用字符指针数组方式传入参数。

	3）int wait(int *status)
	在头文件sys/wait.h中，wait函数可以提供阻塞等待的功能。它等待任意一个子进程退出，若当前没有子进程退出，则一直等待。成功则返回值大于0，是退出子进程的pid；若出错，则返回-1。其中参数int *status为整形空间的地址；保存退出子进程的退出状态，可设置为NULL。
	子进程退出，父进程如果不管不顾，就可能造成 ‘ 僵尸进程 ’ 的问题，进而造成内存泄漏。另外，进程一旦变成僵尸状态，那就刀枪不入， kill -9 也无能为力，因为谁也没有办法杀死一个已经死去的进程。最后，父进程派给子进程的任务完成的如何，我们需要知道。子进程运行完成，结果对还是不对，或者是否正常退出。父进程通过进程等待的方式，回收子进程资源，获取子进程退出信息
	另外，阻塞是指为了完成某个操作，发起调用，但是若不具备操作的完成条件，则调用一直等待。而非阻塞是指为了完成某个操作，发起调用，但是若不具备操作的完成条件 ，立即报错返回。函数wait是阻塞操作。

（1）数组操作
	程序如下图所示
   
思路如下：
	首先，定义整数数组array，声明整数变量sum。
	之后调用fork函数创建一个子进程。fork函数会复制当前进程，创建一个新的子进程。在父进程中，fork函数返回子进程的进程ID，而在子进程中，fork函数返回0。
	如果fork_ret的值为0，表示当前是在子进程中。在子进程中，使用循环遍历数组array，将所有元素累加到变量sum中，并打印出子进程的结果。
	如果fork_ret的值大于0，表示当前是在父进程中。在父进程中，使用wait函数阻塞等待子进程结束，然后打印出父进程的结束消息。
	如果fork_ret的值小于0，表示子进程创建失败，打印出错误消息。
	
	编译并执行，可以看到确实父进程与子进程如预期执行。
 

（2）增加ls -l命令
	在（1）程序基础上增加，新程序如下图所示
  
编译执行后子进程正确计算得到sum，并正确ls -l了usr/bin
 


（3）xv6中的PCB
1）PCB的定义：kernel/proc.h
 
进程控制块实际上是一个结构体，结构体的成员有：
	struct spinlock lock：用于同步访问进程结构体的锁。
	enum procstate state：进程的状态，包括未被使用、被使用、睡眠等。
	void *chan：如果非零，表示进程正在睡眠。
	int killed：如果非零，表示进程已被终止。
	int xstate：返回给父进程的退出状态。
	int pid：进程的ID。
	struct proc *parent：父进程的指针。
	uint64 kstack：进程对应内核栈的虚拟地址
	uint64 sz：进程内存的大小。
	pagetable_t pagetable：用户页表。
	struct trapframe *trapframe：中断桢信息。
	struct context context：进程的上下文，即相关寄存器的值，如edi、esi等。
	struct file *ofile[NOFILE]：进程打开的所有文件。
	struct inode *cwd：当前目录。
	char name[16]：进程的名称。

2）fork的实现：kernel/proc.c
	首先创建子进程结构体np，通过调用allocproc()函数来分配进程资源。
	之后是一些基本的复制操作。用uvmcopy()函数将父进程p的用户内存复制到子进程np中。设置子进程的大小与父进程相同。复制父进程的trapframe，即保存父进程在用户模式下执行时的寄存器状态。
	另外在子进程的陷阱帧中将a0寄存器设置为0，这样子进程在返回时会返回0（之前提到，fork对于子进程返回0） 
	然后遍历父进程的文件描述符数组ofile，如果存在打开的文件，则复制文件描述符到子进程的文件描述符数组中。用idup()函数复制父进程的当前工作目录cwd。将父进程的名称复制到子进程的名称中。
	接着记录子进程的PID。将子进程的parent指针设置为父进程。获取子进程的锁，将子进程的状态设置为RUNNABLE。
	最后，fork返回子进程的PID给父进程。

  
